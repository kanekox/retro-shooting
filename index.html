<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>レトロ・シューティング</title>
<!-- Firebase SDK (v9 compat) -->
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
<script>
// Firebaseの設定
const firebaseConfig = {
  apiKey: "AIzaSyBGvRDZdogbWVR-Vn03lkPzLqMszX0f9eo",
  authDomain: "kanekox-apps.firebaseapp.com",
  projectId: "kanekox-apps",
  storageBucket: "kanekox-apps.firebasestorage.app",
  messagingSenderId: "968979817079",
  appId: "1:968979817079:web:62936aa6570b6387ba1c72",
  measurementId: "G-S5JH6RXKC2"  
};

// Firebase初期化（compatを使うことで既存の v8 スタイルの呼び出しが動作します）
firebase.initializeApp(firebaseConfig);
const db = firebase.firestore();
</script>
<style>
  body { margin: 0; overflow: hidden; background: black; }
  canvas { display: block; margin: 0 auto; background: #000; touch-action: none; }
  #controls {
    position: fixed; bottom: 10px; left: 0; right: 0;
    display: flex; justify-content: space-around; pointer-events: auto;
  }
  .btn {
    background: rgba(255,255,255,0.2); border-radius: 50%;
    width: 60px; height: 60px; text-align: center; line-height: 60px;
    color: white; font-size: 30px; user-select: none;
  }
  /* モーダルスタイル */
  .modal {
    display: none;
    position: fixed;
    z-index: 1;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0,0,0,0.7);
  }
  .modal-content {
    background-color: #333;
    margin: 15% auto;
    padding: 20px;
    border: 2px solid #666;
    width: 300px;
    color: white;
    text-align: center;
    border-radius: 10px;
  }
  .modal input {
    width: 200px;
    padding: 5px;
    margin: 10px 0;
    background: #222;
    border: 1px solid #666;
    color: white;
    font-size: 16px;
  }
  .modal button {
    background: #666;
    color: white;
    border: none;
    padding: 8px 16px;
    margin: 5px;
    cursor: pointer;
    border-radius: 5px;
  }
  .modal button:hover {
    background: #888;
  }
  #scoreList {
    text-align: left;
  }
  #scoreList div {
    padding: 5px 10px;
    border-bottom: 1px solid #444;
  }
  #scoreList div:nth-child(even) {
    background: rgba(255,255,255,0.05);
  }
  #scoreList .date {
    color: #888;
    font-size: 0.8em;
  }
  #showScores:hover {
    background: rgba(255,255,255,0.3) !important;
  }
</style>
</head>
<body>
<canvas id="gameCanvas" width="480" height="640"></canvas>

<!-- スコア入力モーダル -->
<div id="nameInputModal" class="modal">
  <div class="modal-content">
    <h2>新記録達成！</h2>
    <p>ハイスコア: ${score} 点</p>
    <p>名前を入力してください：</p>
    <input type="text" id="playerNameInput" maxlength="10" placeholder="名前を入力">
    <div>
      <button onclick="submitScore()">保存</button>
      <button onclick="closeModal('nameInputModal')">キャンセル</button>
    </div>
  </div>
</div>

<!-- スコア一覧モーダル -->
<div id="scoreListModal" class="modal">
  <div class="modal-content">
    <h2>ハイスコア一覧</h2>
    <div id="scoreList" style="max-height: 300px; overflow-y: auto; margin: 10px 0;"></div>
    <button onclick="closeModal('scoreListModal')">閉じる</button>
  </div>
</div>

<!-- スコア一覧表示ボタン -->
<button id="showScores" onclick="showScoreList()" style="position: fixed; top: 10px; right: 10px; z-index: 1; background: rgba(255,255,255,0.2); color: white; border: none; padding: 5px 10px; cursor: pointer; border-radius: 5px;">
  スコア一覧
</button>

<div id="controls">
  <div class="btn" id="left">←</div>
  <div class="btn" id="shoot">★</div>
  <div class="btn" id="right">→</div>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const keys = { left:false, right:false, space:false };

let player, bullets, enemies, enemyBullets, explosions;
let score, lives, gameOver = false, frame;
let stars = [];
let rankings = []; // トップ10のランキングデータ

let audioCtx;

// ハイスコア管理用
let highScore = 0;

// ステージ／ボス用
let level;
let boss = null;            // ボスオブジェクト（存在しなければnull）
let bossComing = false;     // ボスが出現中 or 出現準備中のフラグ
let bossDefeated = false;

// --- Audio Synth（WebAudioで効果音）---
function playSound(freq, duration, type='sine', vol=0.1){
  if(!audioCtx) return;
  const osc = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  osc.type = type;
  osc.frequency.value = freq;
  g.gain.value = vol;
  osc.connect(g);
  g.connect(audioCtx.destination);
  osc.start();
  osc.stop(audioCtx.currentTime + duration);
}

// --- スコア関連の関数 ---
// ランキングを取得・更新する関数
async function updateRankings() {
  try {
    const snapshot = await db.collection('scores')
      .orderBy('score', 'desc')
      .limit(10)
      .get();

    if (!snapshot.empty) {
      rankings = snapshot.docs.map((doc, index) => {
        const data = doc.data();
        return {
          rank: index + 1,
          name: data.playerName,
          score: data.score
        };
      });
      if (rankings.length > 0) {
        highScore = rankings[0].score;
      }
    }
  } catch (error) {
    console.error('ランキングの取得に失敗しました:', error);
  }
}

// ハイスコアを更新する関数
async function getHighScore() {
  try {
    await updateRankings();
  } catch (error) {
    console.error('ハイスコアの更新に失敗しました:', error);
  }
}

// スコアを保存する関数
async function saveScore(playerName, scoreValue) {
  try {
    await db.collection('scores').add({
      playerName: playerName,
      score: scoreValue,
      date: new Date()
    });
    console.log('スコアを保存しました');
    await updateRankings();
  } catch (error) {
    console.error('スコアの保存に失敗しました:', error);
  }
}

// モーダル関連の関数
function showModal(modalId) {
  const modal = document.getElementById(modalId);
  if (modal) {
    modal.style.display = 'block';
    // 名前入力モーダルの場合、入力欄にフォーカス
    if (modalId === 'nameInputModal') {
      document.getElementById('playerNameInput').focus();
    }
  }
}

function showNameInputDialog() {
  console.log('showNameInputDialog called, gameOver=', gameOver, 'gameOverState=', gameOverState);
  const modalContent = document.querySelector('#nameInputModal .modal-content');
  modalContent.innerHTML = `
    <h2>新記録達成！</h2>
    <p>ハイスコア: ${score} 点</p>
    <p>名前を入力してください：</p>
    <input type="text" id="playerNameInput" maxlength="10" placeholder="名前を入力">
    <div>
      <button onclick="submitScore()">保存</button>
      <button onclick="closeModal('nameInputModal')">キャンセル</button>
    </div>
  `;
  showModal('nameInputModal');
}

function closeModal(modalId) {
  document.getElementById(modalId).style.display = 'none';
  if (modalId === 'nameInputModal') {
    document.getElementById('playerNameInput').value = '';
  }
}

// ランキングデータを取得・更新
async function updateRankings() {
  try {
    const snapshot = await db.collection('scores')
      .orderBy('score', 'desc')
      .limit(10)
      .get();

    if (!snapshot.empty) {
      rankings = snapshot.docs.map((doc, index) => {
        const data = doc.data();
        return {
          rank: index + 1,
          name: data.playerName,
          score: data.score
        };
      });
      if (rankings.length > 0) {
        highScore = rankings[0].score;
      }
    }
  } catch (error) {
    console.error('ランキングの取得に失敗しました:', error);
  }
}

// スコア一覧を表示（モーダル用）
async function showScoreList() {
  try {
    const scoreListDiv = document.getElementById('scoreList');
    scoreListDiv.innerHTML = '';

    if (rankings.length === 0) {
      scoreListDiv.innerHTML = '<div>スコアはまだありません</div>';
      showModal('scoreListModal');
      return;
    }

    rankings.forEach(({rank, name, score}) => {
      const scoreDiv = document.createElement('div');
      scoreDiv.innerHTML = `${rank}位 <strong>${name}</strong>: ${score}`;
    scoreListDiv.appendChild(scoreDiv);
  });

  showModal('scoreListModal');
  } catch (error) {
    console.error('スコア一覧の取得に失敗しました:', error);
  }
}

function submitScore() {
  const name = document.getElementById('playerNameInput').value.trim();
  if (name) {
    saveScore(name, score);
    closeModal('nameInputModal');
  }
}

// モーダルのイベント設定
document.addEventListener('DOMContentLoaded', () => {
  // 全てのモーダルに外側クリックで閉じる機能を追加
  document.querySelectorAll('.modal').forEach(modal => {
    modal.addEventListener('click', e => {
      if (e.target === modal) {
        closeModal(modal.id);
      }
    });
  });

  // 名前入力フォームでEnterキーを処理
  const nameInput = document.getElementById('playerNameInput');
  nameInput?.addEventListener('keypress', e => {
    if (e.key === 'Enter') {
      e.preventDefault();
      submitScore();
    }
  });
});

// Escキーでモーダルを閉じる
document.addEventListener('keydown', e => {
  if (e.key === 'Escape') {
    const activeModal = document.querySelector('.modal[style*="display: block"]');
    if (activeModal) {
      closeModal(activeModal.id);
    }
  }
});



// ゲームオーバー関連の状態（名前入力済みフラグなど）
let gameOverState = { nameEntered: false };
let initCompleted = false;

function init(){
  player = { x:220, y:580, w:40, h:20, speed:5, blink:0 };
  bullets = [];
  enemies = [];
  enemyBullets = [];
  explosions = [];
  score = 0;
  lives = 3;
  gameOver = false;
  gameOverState.nameEntered = false;
  frame = 0;
  level = 1;
  boss = null;
  bossComing = false;
  bossDefeated = false;

  // 星
  stars = [];
  for(let i=0; i<100; i++){
    stars.push({x:Math.random()*canvas.width, y:Math.random()*canvas.height, size:Math.random()*2, speed:1+Math.random()*2});
  }
  
  // ハイスコアを取得
  getHighScore();

  // 初期化完了フラグ
  initCompleted = true;
}

// --- 入力 ---
document.addEventListener('keydown', e=>{
  if(e.code==='ArrowLeft') keys.left=true;
  if(e.code==='ArrowRight') keys.right=true;
  if(e.code==='Space') keys.space=true;
  if(e.code==='Enter' && gameOver) init();
});
document.addEventListener('keyup', e=>{
  if(e.code==='ArrowLeft') keys.left=false;
  if(e.code==='ArrowRight') keys.right=false;
  if(e.code==='Space') keys.space=false;
});

// --- スマホ ---
['left','right','shoot'].forEach(id=>{
  const btn=document.getElementById(id);
  btn.addEventListener('touchstart', (ev)=>{ ev.preventDefault(); keys[id==='left'?'left':id==='right'?'right':'space']=true; });
  btn.addEventListener('touchend', (ev)=>{ ev.preventDefault(); keys[id==='left'?'left':id==='right'?'right':'space']=false; });
});

// --- 敵生成 ---
function spawnEnemy(){
  const speed = 2 + Math.random() * (2 + level * 0.5);
  const type = Math.random() < 0.5 ? 'normal' : 'shooter';
  enemies.push({x:Math.random()*(canvas.width-40), y:-20, w:30, h:20, speed, type});
}

// --- ボス生成 ---
function spawnBoss(){
  // ボスのHPはベース20 + レベルに応じた増加
  boss = {
    x: (canvas.width - 80) / 2,
    y: -80,
    w: 80,
    h: 40,
    hp: 20 + (level-1) * 5,
    maxHp: 20 + (level-1) * 5,
    speed: 2 + level * 0.3,
    dir: 1,
    cooldown: 0
  };
  bossComing = true;
  // 出現SE
  playSound(440, 0.3, 'square', 0.15);
}

// --- 次ステージ（ボス撃破後に呼ぶ） ---
function nextStage(){
  level++;
  boss = null;
  bossComing = false;
  bossDefeated = false;
  // 一旦敵をクリアして弾も消す（演出用）
  enemies = [];
  enemyBullets = [];
  bullets = [];
  addExplosion(canvas.width/2, canvas.height/2, 'white');
  playSound(880, 0.25, 'sine', 0.15);
}

// --- スター更新 ---
function updateStars(){
  for(let s of stars){
    s.y+=s.speed;
    if(s.y>canvas.height){
      s.y=0; s.x=Math.random()*canvas.width;
    }
  }
}

// --- 爆発生成 ---
function addExplosion(x,y,color='yellow'){
  explosions.push({x,y,r:0,max:15,color});
  playSound(200,0.1,'triangle',0.15);
}

// --- 更新 ---
function update(){
  if(gameOver) return;
  frame++;
  updateStars();

  // プレイヤー操作
  if(keys.left) player.x-=player.speed;
  if(keys.right) player.x+=player.speed;
  player.x=Math.max(0,Math.min(canvas.width-player.w,player.x));

  // 弾発射
  if(keys.space && frame%10===0){
    bullets.push({x:player.x+player.w/2-2,y:player.y,w:4,h:10,speed:7});
    playSound(880,0.05,'sawtooth',0.1);
  }
  bullets.forEach(b=>b.y-=b.speed);
  bullets=bullets.filter(b=>b.y>-b.h && !b.dead);

  // 敵（通常）出現：ボスがいないときのみ
  if(!boss && !bossComing){
    if(frame % Math.max(20, 60 - level * 5) === 0) spawnEnemy();
  }

  // 敵更新
  enemies.forEach(e=>{
    e.y+=e.speed;
    if(e.type==='shooter' && frame%90===0)
      enemyBullets.push({x:e.x+e.w/2-2,y:e.y+e.h,w:4,h:10,speed:4,dx:0});
  });
  enemies=enemies.filter(e=>e.y<canvas.height && !e.dead);

  // 敵弾更新（dxを考慮）
  enemyBullets.forEach(b=>{
    b.y += b.speed;
    if (b.dx) b.x += b.dx;
  });
  enemyBullets=enemyBullets.filter(b=>b.y<canvas.height && !b.dead);

  // 衝突（通常弾 vs 通常敵）
  for(let b of bullets){
    for(let e of enemies){
      if(b.x<e.x+e.w && b.x+b.w>e.x && b.y<e.y+e.h && b.y+b.h>e.y){
        e.dead=b.dead=true;
        score+=10;
        addExplosion(e.x+e.w/2,e.y+e.h/2,'orange');
      }
    }
  }
  bullets=bullets.filter(b=>!b.dead);
  enemies=enemies.filter(e=>!e.dead);

  // 当たり判定（プレイヤー vs 敵＋敵弾）
  [...enemies,...enemyBullets].forEach(obj=>{
    if(player.x<obj.x+obj.w && player.x+player.w>obj.x &&
       player.y<obj.y+obj.h && player.y+player.h>obj.y){
      obj.dead=true;
      lives--;
      player.blink=30;
      addExplosion(player.x+player.w/2,player.y+player.h/2,'pink');
      playSound(120,0.1,'square',0.2);
      if(lives<=0) {
        gameOver = true;
        gameOverState.nameEntered = false;
      }
    }
  });
  enemyBullets=enemyBullets.filter(b=>!b.dead);

  // --- ボス出現トリガー ---
  // スコアが閾値に達したらボスを呼ぶ（1回だけ）
  if(score >= level * 100 && !boss && !bossComing){
    // ステージ終了 → ボス登場
    bossComing = true;
    // 少し間を置いてボス登場演出（見せ場）
    setTimeout(()=>spawnBoss(), 500);
  }

  // --- ボス更新 ---
  if(boss){
    // 登場：上から降りてくる
    if(boss.y < 100){
      boss.y += 2;
    } else {
      // 横移動
      boss.x += boss.dir * boss.speed;
      if(boss.x < 0){ boss.x = 0; boss.dir = 1; }
      if(boss.x + boss.w > canvas.width){ boss.x = canvas.width - boss.w; boss.dir = -1; }

      // 攻撃
      boss.cooldown++;
      if(boss.cooldown % 100 === 0){
        // 3方向弾（dxで横方向の速度を付与）
        const speeds = [-1.5, 0, 1.5];
        for(let sdx of speeds){
          enemyBullets.push({
            x: boss.x + boss.w/2 - 2,
            y: boss.y + boss.h,
            w: 6, h: 10,
            speed: 5,
            dx: sdx
          });
        }
        playSound(330,0.08,'square',0.09);
      }
    }

    // ボス被弾判定（プレイヤー弾）
    for (let b of bullets){
      if(b.x < boss.x + boss.w && b.x + b.w > boss.x &&
         b.y < boss.y + boss.h && b.y + b.h > boss.y){
        b.dead = true;
        boss.hp--;
        addExplosion(boss.x + Math.random()*boss.w, boss.y + Math.random()*boss.h, 'yellow');
        playSound(660,0.05,'sawtooth',0.05);
        if(boss.hp <= 0){
          // ボス撃破
          addExplosion(boss.x + boss.w/2, boss.y + boss.h/2, 'white');
          playSound(220,0.3,'triangle',0.2);
          boss = null;
          bossComing = false;
          bossDefeated = true;
          score += 50;
          // 次ステージへ短時間後に移行
          setTimeout(()=> nextStage(), 1500);
          break;
        }
      }
    }

    // ボスがプレイヤーに触れる判定（即ダメージ）
    if(boss && player.x < boss.x + boss.w && player.x + player.w > boss.x &&
       player.y < boss.y + boss.h && player.y + player.h > boss.y){
      // プレイヤー被弾
      lives--;
      player.blink = 30;
      addExplosion(player.x+player.w/2, player.y+player.h/2, 'pink');
      playSound(120,0.1,'square',0.2);
      if(lives<=0) {
        gameOver = true;
        gameOverState.nameEntered = false;
      }
    }
  }

  // 爆発アニメ
  explosions.forEach(ex=>ex.r+=1.5);
  explosions=explosions.filter(ex=>ex.r<ex.max);

  if(player.blink>0) player.blink--;
}

// --- 描画 ---
function draw(){
  // 背景
  ctx.fillStyle='black';
  ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle='white';
  for(let s of stars) ctx.fillRect(s.x,s.y,s.size,s.size);

  // プレイヤー（ハート型）
  if(player.blink%4<2){
    ctx.fillStyle='pink';
    ctx.beginPath();
    const {x,y} = player;
    ctx.moveTo(x+player.w/2,y+player.h);
    ctx.arc(x+player.w*0.3,y+player.h*0.5,player.w*0.2,Math.PI,0);
    ctx.arc(x+player.w*0.7,y+player.h*0.5,player.w*0.2,Math.PI,0);
    ctx.closePath(); ctx.fill();
  }

  // 弾
  ctx.fillStyle='yellow';
  bullets.forEach(b=>ctx.fillRect(b.x,b.y,b.w,b.h));

  // 敵（小さなUFO）
  enemies.forEach(e=>{
    ctx.fillStyle=e.type==='normal'?'red':'orange';
    ctx.beginPath();
    ctx.ellipse(e.x+e.w/2,e.y+e.h/2,e.w/2,e.h/2,0,0,Math.PI*2);
    ctx.fill();
    ctx.fillStyle='white';
    ctx.fillRect(e.x+e.w/4,e.y+e.h/4,e.w/2,2);
  });

  // 敵弾
  ctx.fillStyle='cyan';
  enemyBullets.forEach(b=>ctx.fillRect(b.x,b.y,b.w,b.h));

  // 爆発
  for(let ex of explosions){
    const grad=ctx.createRadialGradient(ex.x,ex.y,0,ex.x,ex.y,ex.r);
    grad.addColorStop(0,'white');
    grad.addColorStop(1,ex.color);
    ctx.fillStyle=grad;
    ctx.beginPath();
    ctx.arc(ex.x,ex.y,ex.r,0,Math.PI*2);
    ctx.fill();
  }

  // ボス描画（あれば）
  if(boss){
    ctx.fillStyle='purple';
    ctx.beginPath();
    ctx.ellipse(boss.x+boss.w/2, boss.y+boss.h/2, boss.w/2, boss.h/2, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle='white';
    ctx.fillRect(boss.x + boss.w/4, boss.y + boss.h/2 - 3, boss.w/2, 6);

    // HPバー（固定位置）
    const barW = 180;
    const barX = (canvas.width - barW)/2;
    ctx.fillStyle = 'black';
    ctx.fillRect(barX-1, 18-1, barW+2, 12+2);
    ctx.fillStyle='red';
    const hpRatio = boss.hp / boss.maxHp;
    ctx.fillRect(barX, 20, barW * Math.max(0, hpRatio), 10);
    ctx.strokeStyle='white';
    ctx.strokeRect(barX, 20, barW, 10);
  }

  // スコアとハイスコア
  ctx.fillStyle='white';
  ctx.font='20px sans-serif';
  ctx.fillText('SCORE: '+score,10,30);
  ctx.fillStyle='gold';
  ctx.fillText('HI-SCORE: '+highScore,160,30);

  // レベル表示（左上）
  ctx.fillStyle='white';
  ctx.font='16px sans-serif';
  ctx.fillText('LEVEL: ' + level, 10, 50);

  // 残機
  for(let i=0;i<lives;i++){
    ctx.fillStyle='pink';
    ctx.beginPath();
    const px = 400 + i*25, py = 25;
    ctx.arc(px-5,py,7,0,Math.PI,false);
    ctx.arc(px+5,py,7,0,Math.PI,false);
    ctx.lineTo(px,py+12);
    ctx.closePath(); ctx.fill();
  }

  if(gameOver){
    // ゲームオーバー時に一度だけ名前入力を表示
    // ハイスコア更新時のみ名前入力を表示
    if(!gameOverState.nameEntered && initCompleted && score > highScore) {
      gameOverState.nameEntered = true;
      setTimeout(() => showNameInputDialog(), 500); // 少し遅延を入れて表示
    }
    
      // ランキング表示
    if (rankings.length > 0) {
      ctx.fillStyle = 'white';
      ctx.font = '24px sans-serif';
      ctx.fillText('TOP 10 SCORES', 180, 180);
      
      ctx.font = '16px sans-serif';
      rankings.forEach(({rank, name, score: rankScore}, index) => {
        const y = 220 + index * 25;
        const text = `${rank}. ${name.padEnd(10)} ${rankScore.toString().padStart(6)}`;
        // 自分のスコアと同じスコアの行を強調表示
        if (rankScore === score) {
          ctx.fillStyle = 'yellow';
        } else {
          ctx.fillStyle = 'white';
        }
        ctx.fillText(text, 140, y);
      });
    } else {
      ctx.fillStyle = 'white';
      ctx.font = '24px sans-serif';
      ctx.fillText('NO SCORES YET', 180, 180);
    }
    
    // GAME OVER表示
    ctx.fillStyle = 'white';
    ctx.font = '40px sans-serif';
    ctx.fillText('GAME OVER', 120, 500);
    ctx.font = '20px sans-serif';
    ctx.fillText('Press ENTER to Restart', 130, 540);
  }
}

// --- メインループ ---
function loop(){
  update();
  draw();
  requestAnimationFrame(loop);
}

// --- Audio 初期化 ---
window.addEventListener('click', ()=>{
  if(!audioCtx){
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
},{once:true});

init();
loop();
</script>
</body>
</html>
